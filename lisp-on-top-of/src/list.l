(load "base.l")
(load "pair.l")

;;; A list data structure using pairs.
;;; A linked-list where the first element in the pair is the current element in the list
;;; The second element is a pointer to the rest of the list
;;; The linked-list ends with the empty list value

(define first car)
(define rest cdr)
(define empty? (lambda (lst) (eq? lst ())))

(define list-eq? (lambda (lst1 lst2)
                   (if (empty? lst1)
                       (empty? lst2)
                     (if (empty? lst2)
                         (empty? lst1)
                       (if (eq? (first lst1) (first lst2))
                           (list-eq? (rest lst1) (rest lst2))
                         #f)))))

(define list-ref (lambda (lst pos)
                   (if (eq? pos 0)
                       (first lst)
                     (list-ref (rest lst) (- pos 1)))))
(define reverse (lambda (lst)
                  (define output ())
                  (while (not (empty? lst))
                    (set! output (cons (first lst) output))
                    (set! lst (rest lst)))
                  output))

(define for-each (lambda (proc lst)
                   (while (not (empty? lst))
                     (proc (first lst))
                     (set! lst (rest lst)))))

(define print-list (lambda (lst)
                     (print "[")
                     (for-each (lambda (el) (print el) (print " ")) lst)
                     (println "]")))

(define filter (lambda (lst pred)
                 (define output ())
                 (while (not (empty? lst))
                   (if (pred (first lst))
                       (set! output (cons (first lst) output))
                     ())
                   (set! lst (rest lst)))
                 (reverse output)))

(define concat! (lambda (lst1 lst2)
                  (define end lst1)
                  (while (and (not (empty? end))
                              (not (empty? (rest end))))
                    (set! end (rest end)))
                  (if (empty? end)
                      (set! lst1 lst2)
                    (set-cdr! end lst2))
                  lst1))

(define sort (lambda (lst key)
               (if (empty? lst)
                   ()
                 ((lambda ()
                    (define pivot (first lst))
                    (define more (sort (filter (rest lst)
                                               (lambda (el) (> (key el)
                                                               (key pivot))))
                                       key))
                    (define less (sort (filter (rest lst)
                                               (lambda (el) (not (> (key el)
                                                                    (key pivot)))))
                                       key))
                    (concat! less (cons pivot more)))))))
                      
(define take (lambda (num lst)
               (define output ())
               (define i 0)
               (while (and (< i num)
                           (not (empty? lst)))
                 (set! output (cons (first lst) output))
                 (set! lst (rest lst))
                 (set! i (+ i 1)))
               (reverse output)))
