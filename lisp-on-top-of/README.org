* Building on top of Lisp

A simple Lisp program example to show that we are all working atop a stack of lies :-)

Our modern programming languages come with standard libraries that give us a lot for free. We also rely heavily on 3rd party libraries to fill the gap in functionality. All these conveniences are definitely helpful, but they can make us forget there's nothing special about code we got for free. We too can write code worthy of being used by other people. We should always drive to write general, reusable code. So long as we have a strong concept of what we're building and define an explicit language around what we're doing we can build our own abstractions via a well-defined interface.

I used Lisp because its simple syntax lends itself to new seamless abstractions. The syntax is so uniform that readers cannot distinguish their functions, 3rd party functions or even built-in functions. Other, lesser languages have a torrent of syntaxes used for various behavior. It is nice to have some visual differentiation, but it makes new abstractions stick out from the language. Some Lisps like Clojure offer more complex syntax so not all Lisps have a uniform syntax, but the distinction between user code and built-in code is still very minor in nearly all dialects of Lisp.

To show the benefit of Lisp as a tool for building seamless abstractions I implemented a problem I got during an interview way back when.

#+BEGIN_QUOTE
Write a script that reads a file prints the 10 most popular words found.
#+END_QUOTE

If we want to write some code to [[file:src/count.l][count the words in a file]] we rely on built-in data structures like dictionaries (maps). We also have to use lists since we end up sorting the list of words and want to get only the first ten elements.

These built-ins (primitives) are essentially /ex nihilo/ (out of nothing) to us since we can use them without thinking how they were created. But data structures don't come out of nothing; someone had to build it. We can do the same. Actually... I did build the [[file:src/map.l][dictionary data structure used]]. You, as the user of this language, didn't have to think about the dictionary code, and that's a good thing. We all know how dictionaries function. You get a value based on a key and you put a value based on a key. There are some other auxiliary functions, but that's the main part. Since we all know how dictionaries work, I or anyone else can build our own version using the same interface.

The dictionary is built on top of a list. Lists are pretty essential to Lisp. After all, Lisp stands for Lisp Processing. I used a data structure that is commonly referred to as an associated list (e.g., Emacs Lisp). Lisp lists have an interface everyone is familiar with. You commonly just want to fetch the first or rest of the list. You can do that with the unsurprising functions of ~first~ and ~rest~. You can also fetch an arbitrary element with ~list-ref~. You can do more complex things like ~filter~ or ~take~ the first N elements. All these capabilities come via that common language we use to talk about lists and are given to you by the platform. Actually... in this case, I built the [[file:src/list.l][list data structure used]]. Again, given a well-defined interface I or anyone can build their own version of seemingly primitive functionality.

Lists are built on top of pairs in Lisp. In Lisp's spirit of simplicity, pairs are the main building block towards complex data structures. All you need is to merge two pieces of data into one abstracted object and all other complex data structures can flow from there. It's like binary for data structures. Pairs are definitely provided by all Lisp implementations since the interpreter/compiler uses them. This data structure is also something you can't build on top of a more basic data structure since this the bottom. The interpeter has to be the one to allocate a piece of memory with two pointers for the first and elements element. A user would have a hard time making their own pair. Actually... I did build the [[file:src/pair.l][pair data structure used]].

Implementing pairs is a little tricky since we don't have useful functions to use, but it turns out functions themselves are all we need. We take advantage of two powerful aspects of funtions to build pairs: lexical scoping and first-class functions. Lexical scoping allows functions to be a closures that retain access to the variables in scope when they were written (hence the name lexical). First-order functions allow us to pass around pieces of code to be executed at a later time. With these two pieces we can have a function saved in a variable that still retains access to the first and second parts of a pair and will return either one when give the write argument. Think of it as a very simple implementation of message passing. With just a few (actual) primitives in the language and the power of lexical scoping and first-class functions we can essentially build any data structure we want from almost nothing.

A language like Lisp has the necessary constituents to build your entire programming environment out of less than 10 functions (excluding any functions that perform necessary side effects like doing I/O). Thankfully the people who wrote this Lisp included all the necessary pieces so I, the developer, can build whatever I want and have it integrate with the rest of language. Actually... I built the [[file:bin/lisp][lisp language and iterpreter used]]. It's a pretty basic interpreter, but it definitely works and can run all the files here. Not only does Lisp provide an environment that allows you to build your word easily, but it's an environment that is easy to build. Again, so long as we have a well defined interface, we can build any abstraction we want. Lisp has a basic, well-defined syntax, and with the explicit support of lexical scoping and first class functions I can create a language that is indistinguishable (modulo bugs) from any other programming environment.

Hopefully I was able to show that the important part of writing programs is defining the language used to describe the solution; not the grammar (i.e., the programming language) but the definition of nouns and verbs (data structures and verbs, respectively) that people can use when speaking either English, Lisp or any other language, programming or otherwise.

Although it's nice to see we can rewrite our environment using our own data structures or algorithms (or even our own language) we're never going to seriously do that (unless we're talking DSLs, but that's a different talk). The important lesson is that what the standard library provides by your platform is both blurry and arbitrary. It's blurry because we developers should not hold any sacrosanct distinction between standard library code and our code. It's all just code written in the same language. It's arbitrary because there isn't a agreed-upon level of abstraction that we expect language authors to provide us. Languages like Python can provide very high level tools like dictionaries or libraries like ~itertools~ while other languages like C give you almost nothing. The important thing to focus on is what level of abstraction *your* code requires. If we're writing a word counting script, I guess we need dictionaries and lists, but what if some code needs to build off of some word-counting algorithm? Then we need to build our own abstraction!

The biggest problem I saw in the Farmers codebase was not poor architecture or poor code on a line-by-line basis but poor abstractions. No one thought about what tools they needed to accomplish their task and build the platform up by writing new tools to meet that demand. Instead, they treated the standard library and what libraries they were using as the end-all-be-all of abstractions and built on top of those while never trying to properly define new verbs and nouns to speak in a higher-level language. They essentially wrote Fortran in Java. They would copy/paste code across the app whenever they needed that piece of functionality. To be fair, they did have some abstractions, but most were poorly implemented because they had so many leaks you could never forget about the details. They would extract a method, but the data that method needed wouldn't be passed as arguments but be stored in global variables which made following the flow nearly impossible. Again, they were writing Fortran subroutines instead of functions.
